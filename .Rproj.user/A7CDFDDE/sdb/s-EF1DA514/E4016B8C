{
    "collab_server" : "",
    "contents" : "\n#' mongodb geospatial methods ( using PyMongo in R )\n#'\n#'\n#' @param host (optional) hostname or IP address or Unix domain socket path of a single mongod or mongos instance to connect to, or a mongodb URI, or a list of hostnames / mongodb URIs. See the reference link for more information.\n#' @param port (optional) port number on which to connect\n#' @param document_class (optional) default class to use for documents returned from queries on this client\n#' @param tz_aware (optional) if TRUE, datetime instances returned as values in a document by this MongoClient will be timezone aware (otherwise they will be naive)\n#' @param connect (optional) if TRUE (the default), immediately begin connecting to MongoDB in the background. Otherwise connect on the first operation\n#' @param ... See the reference link for more details on the \\emph{ellipsis} (...) concerning the additional parameters of the MongoClient()\n#' @param FILE a character string specifying a valid path to a file ( applies to \\emph{read_mongo_bson} method )\n#' @param STR a character string ( applies to \\emph{read_mongo_bson} method )\n#' @param DATA a valid path to a file/folder or a list ( applies to \\emph{geoInsert} method )\n#' @param TYPE_DATA a character string. One of 'folder', 'file', 'dict_one' (takes as input a \\emph{list} or a \\emph{character string}) or 'dict_many' (takes as input a \\emph{list} or a \\emph{character string vector}) ( applies to \\emph{geoInsert} method )\n#' @param COLLECTION a \\emph{pymongo.collection.Collection} object ( applies to \\emph{geoInsert} and \\emph{geoQuery} methods )\n#' @param GEOMETRY_NAME a character string specifying the name of the geometry object, as it appears in the file/string ( applies to \\emph{geoInsert} and \\emph{geoQuery} methods )\n#' @param read_method a character string specifying the method to use to read the data. Either using the \\emph{\"geojsonR\"} (package) or the \\emph{\"mongo_bson\"} utility function ( applies to \\emph{geoInsert} method )\n#' @param QUERY a named list specifying the query to use in mongodb ( applies to \\emph{geoQuery} method )\n#' @param METHOD a character string specifying the method to use to perform geospatial queries in mongodb. One of \"find\", \"aggregate\" OR \"command\" ( applies to \\emph{geoQuery} method )\n#' @param DATABASE a \\emph{\"pymongo.database.Database\"} object ( applies to \\emph{geoQuery} method )\n#' @param TO_LIST either TRUE or FALSE. If TRUE then the output of the \\emph{geoQuery} method will be a list, otherwise a data.table (matrix) object ( applies to \\emph{geoQuery} method )\n#' @export\n#' @details\n#'\n#' the \\emph{geomongo$new} method initializes the MongoClient\n#'\n#' the \\emph{getClient} method returns a \\emph{\"pymongo.mongo_client.MongoClient\"} object\n#'\n#' the \\emph{read_mongo_bson} method allows the user to read a file/string using the \\emph{bson.json_util} module, which loads MongoDB Extended JSON data ( SEE \\emph{https://stackoverflow.com/questions/42089045/bson-errors-invaliddocument-key-oid-must-not-start-with-trying-to-insert} )\n#'\n#' the \\emph{geoInsert} method allows the user to import data to a mongo-db from a \\emph{folder}, \\emph{file} or \\emph{list}\n#'\n#' the \\emph{geoQuery} method allows the user to perform geospatial queries using one of the \\emph{find}, \\emph{aggregate} or \\emph{command} methods\n#'\n#' For spherical query operators to function properly, you must convert distances to radians, and convert from radians to the distances units used by your application.\n#'\n#' To convert distance to radians: divide the distance by the radius of the sphere (e.g. the Earth) in the same units as the distance measurement.\n#' To convert radians to distance: multiply the radian measure by the radius of the sphere (e.g. the Earth) in the units system that you want to convert the distance to.\n#'\n#' The equatorial radius of the Earth is approximately 3,963.2 miles or 6,378.1 kilometers.\n#'\n#' If specifying latitude and longitude coordinates, list the longitude first and then latitude:\n#'\n#' Valid longitude values are between -180 and 180, both inclusive.\n#' Valid latitude values are between -90 and 90 (both inclusive).\n#'\n#' @references\n#' https://api.mongodb.com/python/current/api/index.html, https://docs.mongodb.com/manual/tutorial/calculate-distances-using-spherical-geometry-with-2d-geospatial-indexes/\n#' @docType class\n#' @importFrom R6 R6Class\n#' @import reticulate\n#' @importFrom geojsonR FROM_GeoJson_Schema\n#' @importFrom data.table rbindlist\n#' @section Methods:\n#'\n#' \\describe{\n#'  \\item{\\code{geomongo$new(host = 'localhost', port = 27017, tz_aware = FALSE, connect = TRUE, ...)}}{}\n#'\n#'  \\item{\\code{--------------}}{}\n#'\n#'  \\item{\\code{getClient()}}{}\n#'\n#'  \\item{\\code{--------------}}{}\n#'\n#'  \\item{\\code{read_mongo_bson(FILE = NULL, STR = NULL)}}{}\n#'\n#'  \\item{\\code{--------------}}{}\n#'\n#'  \\item{\\code{geoInsert(DATA = NULL, TYPE_DATA = NULL, COLLECTION = NULL, GEOMETRY_NAME = NULL, read_method = \"geojsonR\")}}{}\n#'\n#'  \\item{\\code{--------------}}{}\n#'\n#'  \\item{\\code{geoQuery(QUERY = NULL, METHOD = NULL, COLLECTION = NULL, DATABASE = NULL, GEOMETRY_NAME = NULL, TO_LIST = FALSE)}}{}\n#'  }\n#'\n#' @usage # init <- geomongo$new(host = 'localhost', port = 27017,\n#'\n#'        #                      tz_aware = FALSE, connect = TRUE, ...)\n#' @examples\n#'\n#' \\dontrun{\n#' library(GeoMongo)\n#'\n#' init = geomongo$new()\n#'\n#' getter_client = init$getClient()\n#'\n#' init_db = getter_client$get_database(\"example_db\")\n#'\n#' init_col = init_db$get_collection(\"example_collection\")\n#'\n#' #--------------------------\n#' # geonear using 'aggregate'\n#' #--------------------------\n#'\n#' query_geonear = list('$geoNear' = list(near = list(type = \"Point\", coordinates = c(-122.5, 37.1)),\n#'\n#'                      distanceField = \"distance\", maxDistance = 900 * 1609.34,\n#'\n#'                      distanceMultiplier = 1 / 1609.34, spherical = TRUE))\n#'\n#'\n#' init$geoQuery(QUERY = query_geonear, METHOD = \"aggregate\", COLLECTION = init_col,\n#'\n#'               DATABASE = init_db, GEOMETRY_NAME = \"location\", TO_LIST = FALSE)\n#' }\n\n\ngeomongo <- R6::R6Class(\"geomongo\",\n\n                        lock_objects = FALSE,\n\n                        public = list(\n\n\n                          #--------------------------------\n                          # method to initialize the client\n                          #--------------------------------\n\n                          initialize = function(host = 'localhost', port = 27017, tz_aware = FALSE, connect = TRUE, ...) {               # document_class = dict by default\n\n                            port = as.integer(port)\n\n                            ARGS = c(as.list(environment()), list(...))\n\n                            cli_mongo = do.call(MONGO$MongoClient, ARGS)\n\n                            private$CLIENT = cli_mongo\n                          },\n\n\n                          #-----------------------\n                          # getter for MongoClient\n                          #------------------------\n\n                          getClient = function() {\n\n                            return(private$CLIENT)\n                          },\n\n                          #---------------------------------------------------------------------------------------------------------------------\n                          # read data from file/string using mongo-bson\n                          # this function can be used both internally\n                          # and externally in order to first read the data\n                          # and then pass the data to the insert function\n                          # Don't add stops/exceptions because they will slow\n                          # down the function especially when inserting many geojson objects\n                          # The reason for reading data using bson is the format of the 'id' parameter when inserting data :\n                          # https://stackoverflow.com/questions/42089045/bson-errors-invaliddocument-key-oid-must-not-start-with-trying-to-insert\n                          #-----------------------------------------------------------------------------------------------------------------------\n\n                          read_mongo_bson = function(FILE = NULL, STR = NULL) {\n\n                            if (!is.null(FILE)) {\n\n                              STR = readLines(FILE)\n\n                              STR = paste(STR, collapse = \"\\n\")\n                            }\n\n                            return(BSON$loads(STR))\n                          },\n\n\n                          #-------------------------------------------------------------------------------\n                          # method : populate database [ the input format must be a reticulate::dict() ]\n                          # TYPE_DATA : 'folder', 'file', 'dict_one', 'dict_many'\n                          # read_method : either \"geojsonR\" or \"mongo_bson\"\n                          #-------------------------------------------------------------------------------\n\n                          geoInsert = function(DATA = NULL, TYPE_DATA = NULL, COLLECTION = NULL, GEOMETRY_NAME = NULL, read_method = \"geojsonR\") {\n\n                            if (!inherits(GEOMETRY_NAME, \"character\")) { stop(\"the 'GEOMETRY_NAME' parameter should be of type character\", call. = F) }\n                            if (TYPE_DATA %in% c(\"folder\", \"file\")) {\n                              if (!inherits(DATA, \"character\")) stop(\"In case that the TYPE_DATA parameter is either a 'folder' or a 'file', then the DATA parameter should be a valid path to a file\", call. = F)\n                              if (!file.exists(DATA)) stop(\"the path to the DATA parameter does not exist\", call. = F)\n                            }\n\n                            private$copy_collection = COLLECTION\n\n                            private$geometry_name = GEOMETRY_NAME\n\n                            if (TYPE_DATA == \"folder\") {\n\n                              geo_json_files = list.files(DATA, full.names = T)\n\n                              for (i in 1:length(geo_json_files)) {\n\n                                if (read_method == \"geojsonR\") {\n\n                                  imp_geoj = geojsonR::FROM_GeoJson_Schema(geo_json_files[i], GEOMETRY_NAME, To_List = T)}         # by default \"To_List = TRUE\", otherwise conversion to python dictionary returns an array which is not accepted in mongodb\n\n                                else if (read_method == \"mongo_bson\") {\n\n                                  imp_geoj = self$read_mongo_bson(FILE = geo_json_files[i], STR = NULL)}\n\n                                else {\n\n                                  stop(\"invalid 'read_method' parameter\", call. = F)\n                                }\n\n                                conv_dict = reticulate::dict(imp_geoj)\n\n                                private$copy_collection$insert_one(conv_dict)\n                              }\n                            }\n\n                            else if (TYPE_DATA == \"file\") {\n\n                              if (read_method == \"geojsonR\") {\n\n                                imp_geoj = geojsonR::FROM_GeoJson_Schema(DATA, GEOMETRY_NAME, To_List = T)}\n\n                              else if (read_method == \"mongo_bson\") {\n\n                                imp_geoj = self$read_mongo_bson(FILE = DATA, STR = NULL)}\n\n                              else {\n\n                                stop(\"invalid 'read_method' parameter\", call. = F)\n                              }\n\n                              conv_dict = reticulate::dict(imp_geoj)\n\n                              private$copy_collection$insert_one(conv_dict)\n                            }\n\n                            else if (TYPE_DATA == \"dict_one\") {\n\n                              if (!inherits(TYPE_DATA, \"character\")) stop(\"the TYPE_DATA parameter should be of type string\", call. = F)\n\n                              if (inherits(DATA, \"list\")) {\n\n                                private$copy_collection$insert_one(reticulate::dict(DATA))}\n\n                              else if (inherits(DATA, \"character\")) {\n\n                                if (read_method == \"geojsonR\") {\n\n                                  input_str = FROM_GeoJson_Schema(DATA, GEOMETRY_NAME, To_List = T)}\n\n                                else if (read_method == \"mongo_bson\") {\n\n                                  input_str = self$read_mongo_bson(FILE = NULL, STR = DATA)}\n\n                                else {\n\n                                  stop(\"invalid 'read_method' parameter\", call. = F)\n                                }\n\n                                private$copy_collection$insert_one(reticulate::dict(input_str))\n                              }\n\n                              else {\n\n                                stop(\"the input data should be either a list or a character string\", call. = F)\n                              }\n                            }\n\n                            else if (TYPE_DATA == \"dict_many\") {\n\n                              if (!inherits(TYPE_DATA, \"character\")) stop(\"the TYPE_DATA parameter should be of type string\", call. = F)\n\n                              INIT_LIST = BUILTINS$list()                           # initialize a python-list to save multiple geojson objects\n\n                              if (inherits(DATA, \"list\")) {\n\n                                for (j in 1:length(DATA)) {                           # simple for loop to insert the data [ in case of too many sublists build an rcpp loop ]\n\n                                  INIT_LIST$append(reticulate::dict(DATA[[j]]))       # append to the list\n                                }\n                              }\n\n                              else if (inherits(DATA, c(\"character\", \"vector\")) && length(DATA) > 1) {\n\n                                for (i in 1:length(DATA)) {\n\n                                  if (read_method == \"geojsonR\") {\n\n                                    INIT_LIST$append(reticulate::dict(FROM_GeoJson_Schema(url_file_string = DATA[i], GEOMETRY_NAME, To_List = T)))}\n\n                                  else if (read_method == \"mongo_bson\") {\n\n                                    input_str_iter = self$read_mongo_bson(FILE = NULL, STR = DATA[i])\n\n                                    INIT_LIST$append(reticulate::dict(input_str_iter))\n                                  }\n\n                                  else {\n\n                                    stop(\"invalid 'read_method' parameter\", call. = F)\n                                  }\n                                }\n                              }\n\n                              else {\n\n                                stop(\"the input data should be either a list or a character string vector\", call. = F)\n                              }\n\n                              private$copy_collection$insert_many(INIT_LIST)        # insert the list in mongodb\n                            }\n\n                            else {\n\n                              stop(\"invalid TYPE_DATA parameter\", call. = F)\n                            }\n\n                            private$idx_2dsphere()              # add 2dsphere indexing (after data is inserted)\n\n                            invisible()\n                          },\n\n\n                          #-------------------------------------------------\n                          # method to perform geo-spatial queries\n                          # METHOD : one of \"find\", \"aggregate\" OR \"command\"\n                          #-------------------------------------------------\n\n                          geoQuery = function(QUERY = NULL, METHOD = NULL, COLLECTION = NULL, DATABASE = NULL, GEOMETRY_NAME = NULL, TO_LIST = FALSE) {\n\n                            if (!inherits(QUERY, \"list\")) { stop(\"the 'QUERY' parameter should be a named list\", call. = F) }\n                            if (is.null(DATABASE)) {\n                              if (is.null(COLLECTION) && is.null(private$copy_collection)) stop(\"give an input object for the COLLECTION parameter\", call. = F)\n                              if (!is.null(COLLECTION) && !is.null(private$copy_collection)) {\n                                Message = c(\"You've already specified a COLLECTION object. The previous collection will be overwritten from the new '\", deparse(substitute(COLLECTION)), \"' collection.\")\n                                warning(paste0(Message), call. = F)}}\n                            if (is.null(DATABASE) && METHOD == 'command' || !is.null(DATABASE) && METHOD != 'command') {\n                              stop(\"in case that the 'DATABASE' parameter is non-NULL, then the 'METHOD' parameter should equal to 'command' ( and the opposite )\", call. = F) }\n\n                            if (!is.null(COLLECTION)) { private$copy_collection = COLLECTION }\n\n                            if (is.null(private$geometry_name) && is.null(GEOMETRY_NAME)) stop(\"the 'GEOMETRY_NAME' is not specified\", call. = F)\n\n                            if (!is.null(private$geometry_name) && !is.null(GEOMETRY_NAME)) warning(\"the 'GEOMETRY_NAME' is already specified\", call. = F)\n\n                            if (!is.null(GEOMETRY_NAME) && is.null(private$geometry_name)) {\n\n                              private$geometry_name = GEOMETRY_NAME\n\n                              private$idx_2dsphere()              # add 2dsphere indexing (in case that the data isn't inserted but only queried)\n                            }\n\n                            if (METHOD == \"aggregate\") {\n\n                              ret_pip_dict = reticulate::dict(QUERY)\n\n                              PIPELINE = list(ret_pip_dict)                          # additional step : dict in R-list\n\n                              res_col = private$copy_collection$aggregate(PIPELINE)\n                            }\n\n                            else if (METHOD == \"find\") {\n\n                              ret_pip_dict = reticulate::dict(QUERY)\n\n                              res_col = private$copy_collection$find(ret_pip_dict)\n                            }\n\n                            else if (METHOD == \"command\") {                    # the PyMongo 'command' equals the 'runCommand' of MongoDB, however there is a difference on how to give the various parameters [ see tests ]\n\n                              Args_Kwargs = private$func_runCommand(QUERY)\n\n                              res_col = do.call(DATABASE$command, Args_Kwargs)\n\n                              res_col = lapply(res_col$results, function(x) private$inner_item_funct(x, remove_ID = \"obj._id\", add_ID = \"id\"))     # process the '_id's\n                            }\n\n                            else {\n\n                              stop(\"valid METHOD is one of 'find', 'aggregate' or 'command'\", call. = F)\n                            }\n\n                            if (TO_LIST) {\n\n                              if (METHOD != 'command') {\n\n                                res_col = reticulate::iterate(res_col)\n                              }\n\n                              return(res_col)\n                            }\n\n                            else {\n\n                              if (METHOD == 'command') {\n\n                                res = data.table::rbindlist(res_col, use.names = T)}                            # use.names = T : items will be bound by matching column names\n\n                              else {\n\n                                loop_res = reticulate::iterate(res_col, f = private$inner_item_funct)           # use the default arguments of 'inner_item_funct' function for 'find', 'aggregate'\n\n                                res = data.table::rbindlist(loop_res, use.names = T)\n                              }\n\n                              return(res)\n                            }\n                          }\n                        ),\n\n                        private = list(\n\n                          CLIENT = NULL,\n\n                          copy_collection = NULL,\n\n                          geometry_name = NULL,\n\n                          #----------------------------------------------\n                          # create 2dsphere indexing [ private function ]\n                          #----------------------------------------------\n\n                          idx_2dsphere = function() {\n\n                            r_idx = list(reticulate::tuple(list(private$geometry_name, MONGO$GEOSPHERE)))          # once inserting of geojson objects is done, build the 2dsphere index\n\n                            private$copy_collection$create_index(r_idx)\n                          },\n\n                          #-----------------------------------------------------------------------------------------------\n                          # helper for 'reticulate::iterate(..., f = ...)' AND 'runCommand' functions [ private function ]\n                          #-----------------------------------------------------------------------------------------------\n\n                          inner_item_funct = function(x, remove_ID = \"_id\", add_ID = \"id\") {\n\n                            tmp_lst = base::unlist(x)                              # unlist\n\n                            copy_id = as.character(tmp_lst[[remove_ID]])           # convert the id to character (hexadecimal), as the returned type is an unrecognized one\n\n                            tmp_lst[[remove_ID]] = NULL                            # delete the initial `_id`, as single quotation marks (due to underscore) cause trouble with data.table's rbindlist()\n\n                            tmp_lst[[add_ID]] = copy_id                            # create new name for id\n\n                            tmp_lst\n                          },\n\n                          #-------------------------------------------------------------------\n                          # helper function for the 'runCommand' function [ private function ]\n                          #-------------------------------------------------------------------\n\n                          func_runCommand = function(LIST) {\n\n                            lapply(LIST, function(SUBLIST) {\n\n                              if (is.list(SUBLIST)) {\n\n                                SUBLIST = reticulate::dict(SUBLIST)       # if item is list build a reticulate::dict(), otherwise return the item\n                              }\n\n                              SUBLIST\n                            })\n                          }\n                        )\n)\n\n\n\n#' simple way to validate a json instance under a given schema\n#'\n#'\n#' @param json_data a named list specifying the input data to validate against the json-schema\n#' @param json_schema a named list specifying the json-schema\n#' @details\n#' Define a json-schema that the input data should follow and then validate the input data against the schema. If the input data follows the schema then by running the function\n#' nothing will be returned, otherwise an error with Traceback will be printed in the R-session.\n#'\n#' In case that \\emph{type} is at the same time also a property name in the json data, then do not include \\emph{\"type\" = \"string\"} in the json schema ( https://github.com/epoberezkin/ajv/issues/137 )\n#' @export\n#' @references https://pypi.python.org/pypi/jsonschema, http://python-jsonschema.readthedocs.io/en/latest/\n#' @examples\n#'\n#' library(GeoMongo)\n#'\n#' if (reticulate::py_available() && reticulate::py_module_available(\"jsonschema\")) {\n#'\n#'  schema_dict = list(\"type\" = \"object\",\n#'\n#'                       \"properties\" = list(\n#'\n#'                         \"name\" = list(\"type\" = \"string\"),\n#'\n#'                            \"location\" = list(\"type\" = \"object\",\n#'\n#'                            \"properties\" = list(\n#'\n#'                             \"type\" = list(\"enum\" = c(\"Point\", \"Polygon\")),\n#'\n#'                             \"coordinates\" = list(\"type\" = \"array\")\n#'  ))))\n#'\n#'\n#'  data_dict = list(\"name\" = \"example location\",\n#'\n#'                  \"location\" = list(\"type\" = \"Point\", \"coordinates\" = c(-120.24, 39.21)))\n#'\n#'\n#'  json_schema_validator(json_data = data_dict, json_schema = schema_dict)\n#'\n#' }\n#'\n\njson_schema_validator = function(json_data = NULL, json_schema = NULL) {\n\n  if (!inherits(json_data, \"list\")) { stop(\"the 'json_data' parameter should be of type list\", call. = F) }\n  if (!inherits(json_schema, \"list\")) { stop(\"the 'json_schema' parameter should be of type list\", call. = F) }\n\n  ret_sch = reticulate::dict(json_schema)\n\n  ret_dat = reticulate::dict(json_data)\n\n  SCHEMA$validate(ret_dat, ret_sch)\n\n  invisible()\n}\n\n\n\n#' MongoDB (bulk) commands\n#'\n#'\n#' @param Argument a character string specifying the mongodb shell command to run from within an R-session\n#' @details\n#' MongoDB shell commands are important for instance if someone has to import/export bulk data to a mongo database. This R function utilizes the \\emph{system} base function to run the mongodb shell command from\n#' within an R-session. See the reference links for more details.\n#' @export\n#' @references https://docs.mongodb.com/manual/reference/program/mongoimport/,  https://docs.mongodb.com/manual/reference/program/mongoexport/\n#' @examples\n#'\n#' \\dontrun{\n#' library(GeoMongo)\n#'\n#' ARGs = \"mongoimport -d DB -c COLLECTION --type json --file /MY_DATA.json\"\n#'\n#' mongodb_console(Argument = ARGs)\n#' }\n\nmongodb_console = function(Argument = NULL) {\n\n  if (!inherits(Argument, \"character\")) { stop(\"the 'Argument' parameter should be of type character\", call. = F) }\n\n  system(Argument)\n\n  invisible()\n}\n\n\n",
    "created" : 1501939223993.000,
    "dirty" : true,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1866188147",
    "id" : "E4016B8C",
    "lastKnownWriteTime" : 1502028621,
    "last_content_update" : 1502029214573,
    "path" : "~/Desktop/kaggle_gpu/add_GITHUB/GeoMongo/R/utils.R",
    "project_path" : "R/utils.R",
    "properties" : {
        "docOutlineVisible" : "1"
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}