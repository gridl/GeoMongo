{
    "collab_server" : "",
    "contents" : "##########################################################################################################################################################################\n##########################################################################################################################################################################\n# methods\n\n# 1st. initialize\n# 2nd. insert geo-data  [ read from folder, user-insertion, read from web ]\n# 3rd. perform geo-queries\n# 4th. validate geo-data (sample)\n# 5th. plot with leaflet\n\n\n############################################################################################################################################################################\n\n\n#' geospatial queries using MongoDB\n#'\n#'\n#' @param string1 a character string.\n#' @param string2 a character string.\n#' @export\n#' @details\n#'\n#'\n#' @references\n#' @docType class\n#' @importFrom R6 R6Class\n#' @import reticulate\n#' @importFrom geojsonR FROM_GeoJson_Schema\n#' @importFrom data.table rbindlist\n#' @section Methods:\n#'\n#' \\describe{\n#'  \\item{\\code{SequenceMatcher$new(string1 = NULL, string2 = NULL)}}{}\n#'\n#'  \\item{\\code{--------------}}{}\n#'\n#'  \\item{\\code{ratio()}}{}\n#'\n#'  \\item{\\code{--------------}}{}\n#'\n#'  \\item{\\code{quick_ratio()}}{}\n#'\n#'  \\item{\\code{--------------}}{}\n#'\n#'  \\item{\\code{real_quick_ratio()}}{}\n#'\n#'  \\item{\\code{--------------}}{}\n#'\n#'  \\item{\\code{get_matching_blocks()}}{}\n#'\n#'  \\item{\\code{--------------}}{}\n#'\n#'  \\item{\\code{get_opcodes()}}{}\n#'  }\n#'\n#' @usage # init <- SequenceMatcher$new(string1 = NULL, string2 = NULL)\n#' @examples\n#'\n#' library(GeoMongo)\n#'\n\ninit_mongo <<- reticulate::import(\"pymongo\")                                  ################ REMOVE [global variable] ONCE ENDED ################\nBSON <<- reticulate::import(\"bson.json_util\")\nBUILTINS <<- reticulate::import_builtins(convert = FALSE)\n\n#----------\n# EXAMPLES:\n#----------\n\n\n# first initialize R6-object\n\ninit = geomongo$new()\n\n\n# then use a getter for the PyMongo-Client [ outside the R6 class ] to define both database and collection\n\ngetter_client = init$getClient()\n\ngetter_client$database_names()\n\ninit_db = getter_client$get_database(\"tmp_db\")                           # DATABASE  [ \"tmp_db\" ]\n\ninit_db$collection_names()\n\ninit_PYM_ret = init_db$get_collection(\"PYM_ret\")\n\n\n#------------------------------------------------------------------------------------\n\nADD_COL = init_db$create_collection(\"NEW_POLYG\")\n\nADD_COL1 = init_db$create_collection(\"rest\")\n\nADD_COL1$count()\n\nimp_geoj = geojsonR::FROM_GeoJson_Schema('/home/lampros/MongoReticulate/GEOJSON/geo6.geojson', 'location', To_List = T)\nDICT = reticulate::dict(imp_geoj)\n\nADD_COL1$insert_one(DICT)\n\nINSERT_DATA = init$geoInsert(DATA = PATH2, TYPE_DATA = \"folder\", COLLECTION = ADD_COL, GEOMETRY_NAME = \"geometry\")\n\nADD_COL$count()\n\nquery_geoIntersects = list('location' = list('$geoIntersects' = list('$geometry' = list(type = \"MultiPolygon\", coordinates = list(list(list(c(102.0, 2.0), c(103.0, 2.0), c(103.0, 3.0), c(102.0, 3.0), c(102.0, 2.0))),\n                                                                                                                                  list(list(c(100.0, 0.0), c(101.0, 0.0), c(101.0, 1.0), c(100.0, 1.0), c(100.0, 0.0)),\n                                                                                                                                       list(c(100.2, 0.2), c(100.8, 0.2), c(100.8, 0.8), c(100.2, 0.8), c(100.2, 0.2)))) ))))\n\n\nfunc_quer_geonear = init$geoQuery(QUERY = query_geoIntersects, METHOD = \"find\", COLLECTION = ADD_COL)\n\n\n\nBSON = reticulate::import(\"bson.json_util\")\n\njson_str = '{\"_id\":{\"$oid\":\"55cba2476c522cafdb053add\"},\"location\":{\"coordinates\":[-73.856077,40.848447],\"type\":\"Point\"},\"name\":\"Morris Park Bake Shop\"}'\n\ndata = BSON$loads(json_str)\nreticulate::dict(data)\n\nlibrary(magrittr)\ndat <- readLines('/home/lampros/MongoReticulate/GEOJSON/geo6.geojson') %>% paste(collapse = \"\\n\") %>% BSON$loads()\n\n\nfunc = function() {\n\n  dat = readLines('/home/lampros/MongoReticulate/GEOJSON/geo6.geojson')\n  dat = paste(dat, collapse = \"\\n\")\n  BSON$loads(dat)\n}\n\n\nmicrobenchmark::microbenchmark(jsonlite::read_json('/home/lampros/MongoReticulate/GEOJSON/geo6.geojson'),\n                               geojsonR::FROM_GeoJson_Schema('/home/lampros/MongoReticulate/GEOJSON/geo6.geojson', geometry_name = 'location', To_List = T),\n                               readLines('/home/lampros/MongoReticulate/GEOJSON/geo6.geojson') %>% paste(collapse = \"\\n\") %>% BSON$loads())\n\n\nmicrobenchmark::microbenchmark(readLines('/home/lampros/MongoReticulate/GEOJSON/geo6.geojson') %>% paste(collapse = \"\\n\") %>% BSON$loads(), func())\n\n#======================================================================================\n\nmongoimport -d db_311 -c three_eleven --type csv --file 311_Service_Requests_from_2011.csv\n\n\nPATH_json_file = '/home/lampros/Downloads/restaurants.json'\nDATABASE = 'tmp_db'\nCOLLECTION = \"restaurants\"\n\ninit_db$collection_names()\n\nbulk_path = paste(c('mongoimport', PATH, '-c', COLLECTION), collapse = \" \")\nbulk_import = system(bulk_path)\n\n#=======================================================================================\n#------------------------------------------------------------------------------------\n\n# populate a mongodb database\n\nfunc_ins = init$geoInsert(DATA = \"/home/lampros/MongoReticulate/GEOJSON\", TYPE_DATA = \"folder\", COLLECTION = init_PYM_ret, GEOMETRY_NAME = \"location\")\n\n# init_PYM_ret$count()                                  # number of items in the updated database\n\n\n# query the database\n\n#--------------------------------\n# 'geonear' [ using 'aggregate' ]\n\nquery_geonear = list('$geoNear' = list(near = list(type = \"Point\", coordinates = c(-122.5, 37.1)), distanceField = \"distance\", maxDistance = 900 * 1609.34,\n\n                                       distanceMultiplier = 1 / 1609.34, spherical = TRUE))\n\n\nfunc_quer_geonear = init$geoQuery(QUERY = query_geonear, METHOD = \"aggregate\")\n# func_quer_geonear = init$geoQuery(QUERY = query_geonear, METHOD = \"aggregate\", COLLECTION = init_PYM_ret)\nfunc_quer_geonear\n\n#------------------------------\n# 'nearSphere' [ using 'find' ]\n\nquery_nearSphere = list('location' = list('$nearSphere' = list('$geometry' = list(type = 'Point', coordinates = c(-122.5, 37.1)), '$maxDistance' = 900 * 1609.34)))\n\nfunc_quer_nearSphere = init$geoQuery(QUERY = query_nearSphere, METHOD = \"find\")\nfunc_quer_nearSphere\n\n#------------------------------\n# 'geoIntersects' [ using 'find' ]\n\nquery_geoIntersects = list('location' = list('$geoIntersects' = list('$geometry' = list(type = \"Polygon\", coordinates = list(list(c(-109, 41), c(-102, 41), c(-102, 37), c(-109, 37), c(-109, 41)))))))\n\nfunc_quer_geoIntersects = init$geoQuery(QUERY = query_geoIntersects, METHOD = \"find\")\nfunc_quer_geoIntersects\n\n#------------------------------\n# 'geoWithin' [ using 'find' ]\n\nquery_geoWithin = list('location' = list('$geoWithin' = list('$geometry' = list(type = \"Polygon\", coordinates = list(list(c(-109, 41), c(-102, 41), c(-102, 37), c(-109, 37), c(-109, 41)))))))\n\nfunc_quer_geoWithin = init$geoQuery(QUERY = query_geoWithin, METHOD = \"find\")\nfunc_quer_geoWithin\n\n#------------------------------\n# 'geoWithin-centerSphere' [ using 'find' ]\n\nquery_geoWithin_sph = list('location' = list('$geoWithin' = list('$centerSphere' = list(c(-122.5, 37.7), 300 / 3963.2))))\n\nfunc_quer_geoWithin_sph = init$geoQuery(QUERY = query_geoWithin_sph, METHOD = \"find\")\nfunc_quer_geoWithin_sph\n\n\n# NOTES :\n\n#-----------------------------------------------------------------------------------------------------------------------------------------------------------------------\n# Important\n#\n# These three queries use radians for distance. Other query types do not.\n#\n# For spherical query operators to function properly, you must convert distances to radians, and convert from radians to the distances units used by your application.\n#\n# To convert:\n#\n# distance to radians: divide the distance by the radius of the sphere (e.g. the Earth) in the same units as the distance measurement.\n# radians to distance: multiply the radian measure by the radius of the sphere (e.g. the Earth) in the units system that you want to convert the distance to.\n#\n# The equatorial radius of the Earth is approximately 3,963.2 miles or 6,378.1 kilometers.\n#-------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n#\n# Warning\n#\n# For spherical queries, use the 2dsphere index result.\n#\n# The use of 2d index for spherical queries may lead to incorrect results, such as the use of the 2d index for spherical queries that wrap around the poles.\n#\n# Note\n#\n# If specifying latitude and longitude coordinates, list the longitude first and then latitude:\n#\n# Valid longitude values are between -180 and 180, both inclusive.\n# Valid latitude values are between -90 and 90 (both inclusive).\n#-------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n\n\n# links :\n\n# https://docs.mongodb.com/manual/tutorial/calculate-distances-using-spherical-geometry-with-2d-geospatial-indexes/\n# https://stackoverflow.com/questions/24138335/pymongo-db-command-options\n#\n\n\n\n\ngeomongo <- R6::R6Class(\"geomongo\",\n\n                        lock_objects = FALSE,\n\n                         public = list(\n\n\n                           #--------------------------------\n                           # method to initialize the client\n                           #--------------------------------\n\n                           initialize = function(host='localhost', port=27017L, tz_aware=FALSE, connect=TRUE, ...) {    # document_class = dict by default\n\n                             ARGS = c(as.list(environment()), list(...))\n\n                             cli_mongo = do.call(init_mongo$MongoClient, ARGS)\n\n                             private$CLIENT = cli_mongo\n                           },\n\n\n                           #-----------------------\n                           # getter for MongoClient\n                           #------------------------\n\n                           getClient = function() {\n\n                             return(private$CLIENT)\n                           },\n\n\n                           #-------------------------\n                           # create 2dsphere indexing\n                           #-------------------------\n\n                           idx_2dsphere = function() {\n\n                             # once inserting is ended create index\n\n                             r_idx = list(reticulate::tuple(list(private$geometry_name, init_mongo$GEOSPHERE)))       # create 2dsphere index\n\n                             private$copy_collection$create_index(r_idx)\n                           },\n\n\n                           #------------------------------------------------------\n                           # read data from file/string using mongo-bson\n                           # this function can be used both internally\n                           # and also externally in order to first read the data\n                           # and then pass the data to the insert function\n                           # don't add stop/exceptions because it will slow\n                           # down the function when inserting many geojson objects\n                           #-------------------------------------------------------\n\n                           read_mongo_bson = function(FILE = NULL, STR = NULL) {\n\n                             if (!is.null(FILE)) {\n\n                               STR = readLines(FILE)\n\n                               STR = paste(STR, collapse = \"\\n\")\n                             }\n\n                             return(BSON$loads(STR))\n                           },\n\n\n                           #-------------------------------------------------------------------------------\n                           # method : populate database [ the format to insert must be a reticulate::dict ]\n                           # TYPE_DATA : 'folder', 'file', 'dict_one', 'dict_many'\n                           # read_method : one of \"geojsonR\", \"mongo_bson\"\n                           #-------------------------------------------------------------------------------\n\n                           geoInsert = function(DATA = NULL, TYPE_DATA = NULL, COLLECTION = NULL, GEOMETRY_NAME = NULL, read_method = \"geojsonR\") {\n\n                             if (TYPE_DATA %in% c(\"folder\", \"file\")) {\n\n                               if (!file.exists(DATA)) stop(\"the path to the DATA parameter does not exist\", call. = F)\n                             }\n\n                             private$copy_collection = COLLECTION\n\n                             private$geometry_name = GEOMETRY_NAME\n\n                             if (TYPE_DATA == \"folder\") {\n\n                               geo_json_files = list.files(DATA, full.names = T)\n\n                               for (i in 1:length(geo_json_files)) {\n\n                                 if (read_method == \"geojsonR\") {\n\n                                   imp_geoj = geojsonR::FROM_GeoJson_Schema(geo_json_files[i], GEOMETRY_NAME, To_List = T)}         # by default \"To_List = TRUE\", otherwise conversion to python dictionary returns an array which is not accepted in mongodb\n\n                                 else if (read_method == \"mongo_bson\") {\n\n                                   imp_geoj = self$read_mongo_bson(FILE = geo_json_files[i], STR = NULL)}\n\n                                 else {\n\n                                   stop(\"invalid 'read_method' parameter\", call. = F)\n                                 }\n\n                                 conv_dict = reticulate::dict(imp_geoj)\n\n                                 private$copy_collection$insert_one(conv_dict)\n                               }\n                             }\n\n                             else if (TYPE_DATA == \"file\") {\n\n                               if (read_method == \"geojsonR\") {\n\n                                 imp_geoj = geojsonR::FROM_GeoJson_Schema(DATA, GEOMETRY_NAME, To_List = T)}\n\n                               else if (read_method == \"mongo_bson\") {\n\n                                 imp_geoj = self$read_mongo_bson(FILE = DATA, STR = NULL)}\n\n                               else {\n\n                                 stop(\"invalid 'read_method' parameter\", call. = F)\n                               }\n\n                               conv_dict = reticulate::dict(imp_geoj)\n\n                               private$copy_collection$insert_one(conv_dict)\n                             }\n\n                             else if (TYPE_DATA == \"dict_one\") {\n\n                               if (!inherits(TYPE_DATA, \"character\")) stop(\"the TYPE_DATA parameter should be of type string\", call. = F)\n                               if (!inherits(DATA, \"list\")) stop(\"the DATA parameter should be of type list\", call. = F)\n\n                               private$copy_collection$insert_one(reticulate::dict(DATA))\n                             }\n\n                             else if (TYPE_DATA == \"dict_many\") {\n\n                               if (!inherits(TYPE_DATA, \"character\")) stop(\"the TYPE_DATA parameter should be of type string\", call. = F)\n                               if (!inherits(DATA, \"list\")) stop(\"the DATA parameter should be of type list\", call. = F)\n\n                               INIT_LIST = BUILTINS$list()\n\n                               for (j in 1:length(DATA)) {                           # simple for loop to insert the data [ in case of too many sublists build an rcpp loop ]\n\n                                 INIT_LIST$append(reticulate::dict(DATA[[j]]))\n                               }\n\n                               private$copy_collection$insert_many(INIT_LIST)\n                             }\n\n                             else {\n\n                               stop(\"invalid TYPE_DATA parameter\", call. = F)\n                             }\n\n                             self$idx_2dsphere()              # add 2dsphere indexing (after data is inserted)\n\n                           },\n\n\n                           #--------------------------------------------------------------------------\n                           # helper for 'reticulate::iterate(..., f = ...)' AND 'runCommand' functions\n                           #--------------------------------------------------------------------------\n\n                           inner_item_funct = function(x, remove_ID = \"_id\", add_ID = \"id\") {\n\n                             tmp_lst = base::unlist(x)                              # unlist\n\n                             copy_id = as.character(tmp_lst[[remove_ID]])           # convert the id to character (hexadecimal), as the returned type is an unrecognized one\n\n                             tmp_lst[[remove_ID]] = NULL                            # delete the initial `_id`, as single quotation marks (due to underscore) cause trouble with data.table's rbindlist()\n\n                             tmp_lst[[add_ID]] = copy_id                            # create new name for id\n\n                             tmp_lst\n                           },\n\n\n                           #-----------------------------------------------\n                           # helper function for the 'runCommand' function\n                           #-----------------------------------------------\n\n                           func_runCommand = function(LIST) {\n\n                             lapply(LIST, function(SUBLIST) {\n\n                               if (is.list(SUBLIST)) {\n\n                                 SUBLIST = reticulate::dict(SUBLIST)\n                               }\n\n                               SUBLIST\n                             })\n                           },\n\n\n                           #------------------------------------------\n                           # method perform geo-spatial queries\n                           # METHOD : \"find\", \"aggregate\" OR \"command\"\n                           #------------------------------------------\n\n                           geoQuery = function(QUERY = NULL, METHOD = NULL, COLLECTION = NULL, DATABASE = NULL, GEOMETRY_NAME = NULL, TO_LIST = FALSE) {\n\n                             if (is.null(DATABASE)) {\n                               if (is.null(COLLECTION) && is.null(private$copy_collection)) stop(\"give an input object for the COLLECTION parameter\", call. = F)\n                               if (!is.null(COLLECTION) && !is.null(private$copy_collection)) {\n                                 Message = c(\"You've already specified a COLLECTION object. The previous collection will be overwritten from the new '\", deparse(substitute(COLLECTION)), \"' collection.\")\n                                 warning(paste0(Message), call. = F)}}\n                             if (is.null(DATABASE) && METHOD == 'command' || !is.null(DATABASE) && METHOD != 'command') {\n                               stop(\"in case that the 'DATABASE' parameter is non-NULL the 'METHOD' parameter should equal to 'command' and the opposite\", call. = F) }\n\n                             if (!is.null(COLLECTION)) { private$copy_collection = COLLECTION }\n\n                             if (is.null(private$geometry_name) && is.null(GEOMETRY_NAME)) stop(\"the 'GEOMETRY_NAME' is not specified\", call. = F)\n\n                             if (!is.null(private$geometry_name) && !is.null(GEOMETRY_NAME)) warning(\"the 'GEOMETRY_NAME' is already specified\", call. = F)\n\n                             if (!is.null(GEOMETRY_NAME) && is.null(private$geometry_name)) {\n\n                               private$geometry_name = GEOMETRY_NAME\n\n                               self$idx_2dsphere()              # add 2dsphere indexing (in case that the data isn't inserted by only queried)\n                             }\n\n                             if (METHOD == \"aggregate\") {\n\n                               ret_pip_dict = reticulate::dict(QUERY)\n\n                               PIPELINE = list(ret_pip_dict)\n\n                               res_col = private$copy_collection$aggregate(PIPELINE)\n                             }\n\n                             else if (METHOD == \"find\") {\n\n                               ret_pip_dict = reticulate::dict(QUERY)\n\n                               res_col = private$copy_collection$find(ret_pip_dict)\n                             }\n\n                             else if (METHOD == \"command\") {\n\n                               Args_Kwargs = self$func_runCommand(QUERY)\n\n                               res_col = do.call(DATABASE$command, Args_Kwargs)\n\n                               res_col = lapply(res_col$results, function(x) self$inner_item_funct(x, remove_ID = \"obj._id\", add_ID = \"id\"))\n                             }\n\n                             else {\n\n                               stop(\"valid METHOD is one of 'find', 'aggregate' or 'command'\", call. = F)\n                             }\n\n                             if (TO_LIST) {\n\n                               if (METHOD != 'command') {\n\n                                 res_col = reticulate::iterate(res_col)\n                               }\n\n                               return(res_col)\n                             }\n\n                             else {\n\n                               if (METHOD == 'command') {\n\n                                 res = data.table::rbindlist(res_col)}\n\n                               else {\n\n                                 loop_res = reticulate::iterate(res_col, f = self$inner_item_funct)           # use the default arguments of 'inner_item_funct' function\n\n                                 res = data.table::rbindlist(loop_res)\n                               }\n\n                               return(res)\n                             }\n                           }\n                           ),\n\n                         private = list(\n\n                           CLIENT = NULL,\n\n                           copy_collection = NULL,\n\n                           geometry_name = NULL\n                         )\n)\n\n\n\n\n\n\n#-------------------------------------------------------------\n# method to validate the json schema\n# both validation-schema and input-string must be a named list\n#-------------------------------------------------------------\n\ninit_schema <<- reticulate::import('jsonschema')                                ################ REMOVE [global variable] ONCE ENDED ################\n\n# json schema validation ( usually in mongodb one can use names that are not consisent with the latest geojson directives ['RFC 7946'] )\n# that means I can't use usual 'geojson' validation tools like 'geojson-lint'. However, I can define a json-schema that my input data\n# follow and then validate a random entry against this schema to spot any errors.\n#\n# https://pypi.python.org/pypi/jsonschema, http://python-jsonschema.readthedocs.io/en/latest/ , https://github.com/Julian/jsonschema/issues/277\n\n\n# EXAMPLES :\n\nschema_dict = list(\"type\" = \"object\",\n\n                   \"properties\" = list(\n\n                     \"name\" = list(\"type\" = \"string\"),\n\n                     \"location\" = list(\"type\" = \"object\",\n\n                                       \"properties\" = list(\n\n                                         \"type\" = list(\"enum\" = c(\"Point\", \"Polygon\")),                     # in case that \"type\" is at the same time also a property name do not include \"type\" = \"string\" , https://github.com/epoberezkin/ajv/issues/137\n\n                                         #\"type1\" = list(\"type\" = \"string\", \"enum\" = c(\"Point\", \"Polygon\")),\n\n                                         \"coordinates\" = list(\"type\" = \"array\")\n                                       ))))\n\ndata_dict = list(\"name\" = \"Squaw Valley\", \"location\" = list(\"type\" = \"Point\", \"coordinates\" = c(-120.24, 39.21)))\n\n# data_dict_INVALID = list(\"name\" = \"Squaw Valley\", \"location\" = list(\"type\" = \"Point\", \"coordinates\" = c(-120.24, 39.21)))\n\n\n\njson_schema_validator = function(json_string = NULL, json_schema = NULL) {\n\n  ret_sch = reticulate::dict(json_schema)\n\n  ret_dat = reticulate::dict(json_string)\n\n  init_schema$validate(ret_dat, ret_sch)\n}\n\n\n\njson_schema_validator(json_string = data_dict, json_schema = schema_dict)\n\n\n#-----------------------------------------------------------------------------------------------------------------------------------\n# The 'mongodb_console' function can be used to run mongodb shell commands [ commands that can't be run from within PyMongo ]\n#\n# bulk mongodb import and export of data using the 'system()' function from within R\n# the parameters for mongoimport and mongoexport can be found in :\n#                      - mongoimport : https://docs.mongodb.com/manual/reference/program/mongoimport/\n#                      - mongoexport : https://docs.mongodb.com/manual/reference/program/mongoexport/\n#\n# The 'Argument' parameter should be of type string such as : \"mongoimport /home/lampros/Downloads/restaurants.json -c restaurants\"\n#\n#  /home/lampros/Downloads/restaurants.json : is the path to the .json file\n#                               restaurants : is the name of the collection, in which the data should be inserted\n#\n# The function doesn't return an object in R\n#-----------------------------------------------------------------------------------------------------------------------------------\n\nARGUMENT = \"mongoimport -d tmp_db -c restaurants --type json --file /home/lampros/Downloads/restaurants.json\"\n\n\nmongodb_console = function(Argument = NULL) {\n\n  if (!inherits(Argument, \"character\")) { stop(\"the 'Argument' parameter should be of type character\", call. = F) }\n\n  system(Argument)\n\n  invisible()\n}\n\n\n#------------------------------------\n\nmongodb_console(Argument = ARGUMENT)       # bulk import of json-data in the 'restaurants' collection\n\ninit_db$collection_names()                 # observe if the new collection ( 'restaurants' ) is created\n\ninit_col = init_db$get_collection(\"restaurants\")\n\ninit_col$find_one()\n\n\n#-----------------------------------\n\nARGUMENT_neighborhoods = \"mongoimport -d tmp_db -c neighborhoods --type json --file /home/lampros/Downloads/neighborhoods.json\"\n\n\nmongodb_console(Argument = ARGUMENT_neighborhoods)       # bulk import of json-data in the 'neighborhoods' collection\n\ninit_db$collection_names()                               # observe if the new collection ( 'neighborhoods' ) is created\n\ninit_neigh = init_db$get_collection(\"neighborhoods\")\n\ninit_neigh$find_one()\n\n\n#===================================================================================================================================================================================\n\n# geoqueries based on bulk import         [ EXAMPLES FROM : https://docs.mongodb.com/manual/tutorial/geospatial-tutorial/ ]\n\n\n#---------------neighborhoods\n\nQUER = list('geometry' = list('$geoIntersects' = list('$geometry' = list('type' = 'Point', 'coordinates' = c(-73.93414657, 40.82302903)))))\n\n\ninit = geomongo$new()\n\ngetter_client = init$getClient()\n\ngetter_client$database_names()\n\n\ninit_neighb = init_db$get_collection(\"neighborhoods\")\n\n\nints = init$geoQuery(QUERY = QUER, METHOD = \"find\", COLLECTION = init_neighb, GEOMETRY_NAME = 'geometry', TO_LIST = TRUE)\nints              # the returned list is an un-named list of length 1 [ this un-named list will include all other sublists ]\nints[[1]]['geometry']$geometry       # extract the 'geometry' object by taking the first list ( ints[[1]] )\n\n\n\n#--------------restaurants\n\ninit_rest = init_db$get_collection(\"restaurants\")\n\nQUER_rest = list('location' = list('$geoWithin' = list('$geometry' = ints[[1]]['geometry']$geometry)))          # take the result from the previous 'QUER'\n\nints_rest = init$geoQuery(QUERY = QUER_rest, METHOD = \"find\", COLLECTION = init_rest, GEOMETRY_NAME = 'location', TO_LIST = F)\nints_rest\n\n\n#----------------geowithin\n\n\nrest_geowithin = list('location' = list('$geoWithin' = list('$centerSphere' = list(c(-73.93414657, 40.82302903 ), 5 / 3963.2 ))))\n\nquer_geowithin = init$geoQuery(QUERY = rest_geowithin, METHOD = \"find\", COLLECTION = init_rest, GEOMETRY_NAME = 'location', TO_LIST = F)\nquer_geowithin\n\n\n#---------------nearSphere\n\n# returns all restaurants within five miles of the user in sorted order from nearest to farthest\n\nQUER_nearsph = list('location' = list('$nearSphere' = list('$geometry' = list('type' = 'Point', 'coordinates' = c(-73.93414657, 40.82302903)), '$maxDistance' = 5 * 1609.34)))\n\nquer_nearSphere = init$geoQuery(QUERY = QUER_nearsph, METHOD = \"find\", COLLECTION = init_rest, GEOMETRY_NAME = 'location', TO_LIST = F)\nquer_nearSphere\n\n\n#===================================================================================================================================================================================\n\n# EXAMPLE FOR THE \"runCommand\" in mongodb\n\n\ninit = geomongo$new()\n\ngetter_client = init$getClient()\n\ngetter_client$database_names()\n\ninit_db = getter_client$get_database(\"tmp_db\")\n\ninit_db$collection_names()\n\n# init_places = init_db$create_collection(\"places\")\ninit_places = init_db$get_collection(\"places\")\n\n\nstr1 = list('name' = \"Central Park\", 'location' =  list('type' = \"Point\", 'coordinates' = c(-73.97, 40.77)), 'category' = \"Parks\")\nstr2 = list('name' = \"Sara D. Roosevelt Park\", 'location' =  list('type' = \"Point\", 'coordinates' = c(-73.9928, 40.7193)), 'category' = \"Parks\")\nstr3 = list('name' = \"Polo Grounds\", 'location' =  list('type' = \"Point\", 'coordinates' = c(-73.9375, 40.8303)), 'category' = \"Stadiums\")\n\n\ninit$geoInsert(DATA = reticulate::dict(str1), TYPE_DATA = \"dict_one\", COLLECTION = init_places, GEOMETRY_NAME = \"location\", read_method = \"geojsonR\")\ninit$geoInsert(DATA = reticulate::dict(str2), TYPE_DATA = \"dict_one\", COLLECTION = init_places, GEOMETRY_NAME = \"location\", read_method = \"geojsonR\")\ninit$geoInsert(DATA = reticulate::dict(str3), TYPE_DATA = \"dict_one\", COLLECTION = init_places, GEOMETRY_NAME = \"location\", read_method = \"geojsonR\")\n\n\ninit_places$find_one()\n\nQUER_dat = list('location' = list('$near' = list('$geometry' = list('type' = \"Point\", 'coordinates' = c(-73.9667, 40.78)), '$minDistance' = 1000, '$maxDistance' = 5000)))\n\nquer_dat = init$geoQuery(QUERY = QUER_dat, METHOD = \"find\", COLLECTION = init_places, GEOMETRY_NAME = 'location', TO_LIST = F)\nquer_dat\n\n\n#----------runCommand\n\nquer_command = list('geoNear' = \"places\", 'near' = list('type' = \"Point\", 'coordinates' = c(-73.9667, 40.78)), 'spherical' = TRUE, 'query' = list('category' = \"Parks\"))\n\nArgs_Kwargs = list(\"geoNear\", \"places\",\n\n                   near = list(\"type\" = \"Point\", \"coordinates\" = c(-73.9667, 40.78)),\n\n                   spherical = TRUE,\n\n                   query = list(\"category\" = \"Parks\"))\n\n\nfunc_runCommand = function(LIST) {\n\n  lapply(LIST, function(SUBLIST) {\n\n    if (is.list(SUBLIST)) {\n\n      SUBLIST = reticulate::dict(SUBLIST)\n    }\n\n    SUBLIST\n  })\n}\n\n\nfunc_runCommand(Args_Kwargs)\n\n\ndo.call(init_db$command, func_runCommand(Args_Kwargs))\n\n\n# init_db$command(\"geoNear\", \"places\",\n#\n#                 near = reticulate::dict(list(\"type\" = \"Point\", \"coordinates\" = c(-73.9667, 40.78))),\n#\n#                 spherical = TRUE,\n#\n#                 query = reticulate::dict(list(\"category\" = \"Parks\")))\n\n\n# The initial command : db.runCommand({geoNear: \"places\", near: { type: \"Point\", coordinates: [ -73.9667, 40.78 ] }, spherical: true, query: { category: \"Parks\" }})\n# translates to : db.command(\"geoNear\", \"places\", near = { \"type\": \"Point\", \"coordinates\": [ -73.9667, 40.78 ] }, spherical = True, query = { \"category\": \"Parks\" })\n# in PyMongo\n\n\nPLACES = init_db$get_collection(\"places\")\n\ninit$geoQuery(QUERY = Args_Kwargs, METHOD = \"command\", COLLECTION = PLACES, DATABASE = init_db, GEOMETRY_NAME = \"location\", TO_LIST = F)\n\n\n\n#--------------------------------------------insert \"dict_many\" [ nested list ]\n\ninit_places1 = init_db$create_collection(\"places1\")\n\n\nBUILTINS = reticulate::import_builtins(convert = FALSE)\n\nINIT_LIST = BUILTINS$list()\n\nNESTED = list(list('name' = \"Central Park\", 'location' =  list('type' = \"Point\", 'coordinates' = c(-73.97, 40.77)), 'category' = \"Parks\"),\n              list('name' = \"Sara D. Roosevelt Park\", 'location' =  list('type' = \"Point\", 'coordinates' = c(-73.9928, 40.7193)), 'category' = \"Parks\"),\n              list('name' = \"Polo Grounds\", 'location' =  list('type' = \"Point\", 'coordinates' = c(-73.9375, 40.8303)), 'category' = \"Stadiums\"))\n\nlength(NESTED)\n\nfor (i in 1:length(NESTED)) {\n\n  INIT_LIST$append(reticulate::dict(NESTED[[i]]))\n}\n\nBUILTINS$len(INIT_LIST)\n\n#INIT_ARRAY = NUMPY$array(INIT_LIST)\n\ninit$geoInsert(DATA = INIT_LIST, TYPE_DATA = \"dict_many\", COLLECTION = init_places1, GEOMETRY_NAME = \"location\", read_method = \"geojsonR\")\n\ninit_places1$count()\n\nreticulate::dict(init_places1$find_one())\n\n\n\n#=========================================================\n\ninit_places2 = init_db$create_collection(\"places2\")\n\nONE_LIST = list('name' = \"Central Park\", 'location' =  list('type' = \"Point\", 'coordinates' = c(-73.97, 40.77)), 'category' = \"Parks\")\n\ninit$geoInsert(DATA = ONE_LIST, TYPE_DATA = \"dict_one\", COLLECTION = init_places2, GEOMETRY_NAME = \"location\", read_method = \"geojsonR\")\n\ninit_places2$find_one()\n\n\n#=========================================================\n\ninit_places3 = init_db$create_collection(\"places3\")\n\ninit$geoInsert(DATA = NESTED, TYPE_DATA = \"dict_many\", COLLECTION = init_places3, GEOMETRY_NAME = \"location\", read_method = \"geojsonR\")\n\ninit_places3$count()\n\ninit_places3$find_one()\n\n##########################################################################################################################################\n##########################################################################################################################################\n\n#--------------------------------\n# validation in PyMongo - MongoDB\n#--------------------------------\n\n\n# https://jira.mongodb.org/browse/PYTHON-1064\n# https://docs.mongodb.com/manual/core/document-validation/\n# https://docs.mongodb.com/manual/reference/command/create/    [ SEE 'validator' ]\n# http://www.technicalkeeda.com/mongodb-tutorials/mongodb-create-collection\n# https://docs.mongodb.com/manual/reference/operator/query/type/#document-type-available-types\n# http://stats.seandolinar.com/collecting-twitter-data-storing-tweets-in-mongodb/\n# https://stackoverflow.com/questions/27374343/pymongo-cannot-get-and-or-to-work\n# https://www.compose.com/articles/document-validation-in-mongodb-by-example/\n#\n\n\n#============================================================================\n\n# reticulate::py_module_available('jsonschema')\n#\n# init_schema = reticulate::import('jsonschema')\n#\n#\n# schema_dict = list(\"type\" = \"object\",\n#\n#                    \"properties\" = list(\n#\n#                      \"name\" = list(\"type\" = \"string\"),\n#\n#                      \"location\" = list(\"type\" = \"object\",\n#\n#                                        \"properties\" = list(\n#\n#                                          \"type\" = list(\"enum\" = c(\"Point\", \"Polygon\")),                     # in case that \"type\" is at the same time also a property name do not include \"type\" = \"string\" , https://github.com/epoberezkin/ajv/issues/137\n#\n#                                          #\"type1\" = list(\"type\" = \"string\", \"enum\" = c(\"Point\", \"Polygon\")),\n#\n#                                          \"coordinates\" = list(\"type\" = \"array\")\n#                                        ))))\n#\n# data_dict = list(\"name\" = \"Squaw Valley\", \"location\" = list(\"type\" = \"Point\", \"coordinates\" = c(-120.24, 39.21)))\n#\n# # data_dict_INVALID = list(\"name\" = \"Squaw Valley\", \"location\" = list(\"type\" = \"Point\", \"coordinates\" = c(-120.24, 39.21)))\n#\n# ret_sch = reticulate::dict(schema_dict)\n# ret_sch\n#\n# ret_dat = reticulate::dict(data_dict)\n# ret_dat\n#\n#\n# init_schema$validate(ret_dat, ret_sch)\n\n\n\n\n\n",
    "created" : 1501146696822.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1748978817",
    "id" : "EBD64CB7",
    "lastKnownWriteTime" : 1501174404,
    "last_content_update" : 1501174404772,
    "path" : "~/MongoReticulate/pymongo_R6.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}